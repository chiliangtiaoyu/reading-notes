# 内存布局

## 对象头

在java虚拟机中，每一个对象都有对象头，对象头分为标记字段和类型指针组成。

**标记字段**用于存储哈希吗、分代年龄、gc信息、锁信息之类的。

**类型指针**指向该对象的类。

在64位的操作系统中，标记字段和类型指针分别占据了64位，也就是16个字节，比如一个Integer类型的本身大小就4个字节对象头就占据了16字节，这也是为什么要引入基本类型的原因。

因为内存是非常宝贵的资源，所以对类型指针的大小进行了一个压缩，压缩到了32位，也就是4个字节，压缩过后对象头只占据12个字节

什么是对象压缩算法呢，我们可以把对象看做一辆辆货车比如说货车A占据了0和1两个车位，货车B占据了2和3，货车C占据了4和5号车位。

**按照通过车位寻找车**，比如查找2号车位就可以发现是货车B，相同道理指针是五号车位那么就找到货车C，这时候指针必须存012345的值才能找到所有车的位置，也就是32位的压缩指针寻址范围为2^31个对象。

**通过给货车编号查找**，ABC分别编号为012号车，那么指针为1的时候*2就可以找到2号车，这样指针只用存012就可以找到所有车的位置，寻址范围2^32个对象

就算中间有比较大的车（对象）占据了三个车位，那么就把下一辆车的编号就跳过冲突编号。

这个时候会有一个问题，就是我们的车位必须从偶数位开始的，不然内存寻址就会出错，所以这个概念就叫做**内存对齐**。

### 内存对齐

java虚拟机规定每个对象的起始地址必须是8字节的整数倍，所以32位的指针就可以寻址2^35个字节的空间也就是32GB内存。而因为内存对齐的缘故，如果一个对象不是刚好用到8字节的整数倍，那么这个浪费的内存就叫做内存填充。

当超出指针寻址范围的时候，就会对压缩指针进行解引用操作，将压缩指针左移三位加上一个固定偏移量就可以得寻址32GB空间的伪64位指针。

### 字段重排

其实就算指针没有被压缩，也会字段也会对齐的，比如说long、double类型的数值必须为8的倍数，是为了放这些字段出现在同一缓存行，如果出现在不同缓存，那么读取或者写入的时候都会对两个缓存行进行操作，也就污染了两行，这对程序执行效率是不利的。

**字段对齐** 指如果一个字段占据M个字节，那么这个字段就必须以NM倍数对齐。

比如64位压缩指针对象只装有long类型字段，那么这个对象的理想大小为 对象头+字段大小，而实际是对象头占据12个字节，long类型占据8字节，由于内存对齐的缘故long的起始地址必须是16开始，那么16-12=4，中间有四个字节被浪费，当然jvm也做了一些优化，比如这个对象还有一个int类型的值，刚好占据四个字节，那么就会虚拟机就会优化调整字段位置进行填充，而不是根据字段声明的位置进行内存排列。

