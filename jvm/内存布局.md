# 内存布局与回收

## 对象头

在java虚拟机中，每一个对象都有对象头，对象头分为标记字段和类型指针组成。

**标记字段**用于存储哈希吗、分代年龄、gc信息、锁信息之类的。

**类型指针**指向该对象的类。

在64位的操作系统中，标记字段和类型指针分别占据了64位，也就是16个字节，比如一个Integer类型的本身大小就4个字节对象头就占据了16字节，这也是为什么要引入基本类型的原因。

因为内存是非常宝贵的资源，所以对类型指针的大小进行了一个压缩，压缩到了32位，也就是4个字节，压缩过后对象头只占据12个字节

什么是对象压缩算法呢，我们可以把对象看做一辆辆货车比如说货车A占据了0和1两个车位，货车B占据了2和3，货车C占据了4和5号车位。

**按照通过车位寻找车**，比如查找2号车位就可以发现是货车B，相同道理指针是五号车位那么就找到货车C，这时候指针必须存012345的值才能找到所有车的位置，也就是32位的压缩指针寻址范围为2^31个对象。

**通过给货车编号查找**，ABC分别编号为012号车，那么指针为1的时候*2就可以找到2号车，这样指针只用存012就可以找到所有车的位置，寻址范围2^32个对象

就算中间有比较大的车（对象）占据了三个车位，那么就把下一辆车的编号就跳过冲突编号。

这个时候会有一个问题，就是我们的车位必须从偶数位开始的，不然内存寻址就会出错，所以这个概念就叫做**内存对齐**。

### 内存对齐

java虚拟机规定每个对象的起始地址必须是8字节的整数倍，所以32位的指针就可以寻址2^35个字节的空间也就是32GB内存。而因为内存对齐的缘故，如果一个对象不是刚好用到8字节的整数倍，那么这个浪费的内存就叫做内存填充。

当超出指针寻址范围的时候，就会对压缩指针进行解引用操作，将压缩指针左移三位加上一个固定偏移量就可以得寻址32GB空间的伪64位指针。

### 字段重排

其实就算指针没有被压缩，也会字段也会对齐的，比如说long、double类型的数值必须为8的倍数，是为了放这些字段出现在同一缓存行，如果出现在不同缓存，那么读取或者写入的时候都会对两个缓存行进行操作，也就污染了两行，这对程序执行效率是不利的。

**字段对齐** 指如果一个字段占据M个字节，那么这个字段就必须以NM倍数对齐。

比如64位压缩指针对象只装有long类型字段，那么这个对象的理想大小为 对象头+字段大小，而实际是对象头占据12个字节，long类型占据8字节，由于内存对齐的缘故long的起始地址必须是16开始，那么16-12=4，中间有四个字节被浪费，当然jvm也做了一些优化，比如这个对象还有一个int类型的值，刚好占据四个字节，那么就会虚拟机就会优化调整字段位置进行填充，而不是根据字段声明的位置进行内存排列。

## 垃圾回收

### 引用计数法和可达性分析

**引用计数法**：为每个对象分配一个计数器，每有一个引用指向自己，计数器就加一，引用变更指向为其他对象，计数就减一。此方式不能统计互相引用的情况，比如两个无用的对象互相指向对方。造成无法回收的问题。

**可达性分析**：把一系列的GC root作为初始存活的对象集合，然后从该集合出发，搜寻能**被该集合引用到的对象**并将其加入其中，搜寻不到的就是死亡的对象。那么什么是GC root呢，一般是指堆外指向堆内的引用。

一般可作为GC root的又以下四种：

1.方法栈帧里的局部变量（常量）；

2.JNI handles；

3.已加载类的静态变量；

4.启动未停止的java线程；

### 安全点与stop-the-world

stop the world是在垃圾收集线程执行的时候，其他线程处于停止状态，传统垃圾收集器是通过安全点机制来实现的，就是要开启垃圾回收的时候喊出”安全词“。其他线程收到的时候就停止操作。

安全点的目的不是为了让其他线程停下，而是找到一个稳定的状态，就是不会对堆栈发生操作的状态。

java线程有JNI代码执行状态、解释执行字节码执行状态、执行即时编译器产生的机器码状态、线程阻塞状态。其中三种状态是运行状态需保证进入安全点时间必须是可预测的，不然会陷入长时间等待提高回收垃圾的成本。

对于JNI执行的代码由于需要非java API来实现，所以在方法入口会插入安全点检测。阻塞线程处于线程调度器控制之下因此是安全的，字节码与字节码之间会插入安全点检测，机器码由于是直接在底层硬件上执行所以情况比较复杂，所以必须在编译成机器码之前插入安全点检测，会在方法出口和非循环计数的回边上插入安全点检测，为什么不在机器码块中间插入有两点原因：

1.安全点检测本身有开销，不过hotspot已将机器码中的安全点检测优化成一个**内存访问**操作了，在有安全点检测的情况下会将安全点检测的内存访问页设置为不可读，并设置一个segfault处理器，截获来访问此页的线程并挂起。

2.因为即时编译成的机器码打乱了原本栈帧的对象分布结构（**标量替换？逃逸分析传入对象是否能进行标量替换，标量替换后有没有引用指向**），所以在进行安全点检测的时候需要把寄存器里的引用信息提供出来，以便于GC ROOT的枚举

所以以下几种情况会插入安全点检测

1.本地方法执行的入口会插入安全点

2.字节码与字节码之间插入

3.机器码的非循环计数回边和方法入口

但是安全点检测

### 垃圾回收三种方式

1.标记清除

把死亡的对象标记，需要内存的时候清除，缺点是内存不连续

2.压缩算法

把存活的对象放到一起，内存空间连续，性能不好

3.复制算法

内存分为from和to两块区域，每次把from里存活的对象拷贝到to区域，然后交换指针，to区域总是空的。浪费内存

## 虚拟机的内存分布

java虚拟机把堆内存分为新生代老年代。其中又把新生代分为eden区和survivor区，其中survivor区又分为两块大小一样的区域分别称之为from和to区域。

默认情况下java虚拟机采用的**动态分配的策略**，根据对象生成的速度动态分配区域大小。

一般来说我们new对象需要申请一块内存，为了防止几个对象同时申请一块内存造成冲突，所以会通过**加锁**的方式为每个线程提前分配一块内存连续区域，这块区域由两个重要的指针维护，一个指针指向剩余内存的**起始位置**，一个指针指向**内存的末尾**。每次new对象申请内存的时候起始内存地址就会往后**滑动做加法**，也可以叫做**指针碰撞**。不够了在继续申请，这项技术叫做TLAB。

当eden区域内存不够用的时候就会发生MinorGC，会把eden区域存活的对象和survivor中的from区域存活的对象会被复制到to，然后交换from和to的指针。jvm会记录survivor区域来回被复制的对象超过15次的就去老年代。**survivor区域使用超过50%**也会使年龄大点的对象晋升老年代。大对象也是老年代分配。

因为eden百分之八十的对象都会死掉所以说需要复制的对象是很少的。因此性能很高，但是又会有一个问题老年代也会有指向新生代的引用，那么这个引用也会被加入GC roots集合中，那不是又要做一次全堆扫描？

### 卡表

Hotspot给出的卡表技术（Card Table）就是防止做全堆扫描的，首先会对堆划分成512字节的卡，并且维护一张卡表存储每张卡所对应的标志位，这个标志位代表这个这个卡的内存区域是否可能有**指向新生代的引用**，如果有就标记为脏卡，Minor GC的时候就不用扫描整个老年代，只扫描脏卡就行了，并把指向新生代的引用加入到GC root这个集合当中，并把**脏卡标志清除**，等待下一次标记。

那么什么情况下会被标记为脏卡呢？

jvm需要截获每次对象**引用变更**操作，并作出对应写标志位的操作。

在解释执行的时候比较容易判断是否需要写标志，但是在即时编译的机器码中就需要插入额外的逻辑，也就是写屏障（write barrier 不是volatile的内存屏障），精简为一个位运算指令和存储指令。就是通过位运算得到一个**映射到卡表的索引**，然后写脏卡。所以只要是引用变更都被标记为脏卡。宁可错杀不可放过。

但是在高并发情况下也有问题就是虚共享的问题，就是卡表是一个byte数组，对一个64字节的缓存行来说就对应64*512也就是32KB大小的内存区域，当这个内存区域由两张及以上的卡要进行写标志位的时候由于是同一缓存行，肯定会发生竞争关系就会带来同步、无效化等问题。从而间接影响程序性能

http://rednaxelafx.iteye.com/blog/1042471

http://rednaxelafx.iteye.com/blog/174865

http://rednaxelafx.iteye.com/blog/1044951

###  Java 内存模型与 happens-before 关系 

对于没有数据前后驱依赖关系的字节流，并不保证靠前的代码先于靠后代码执行。happens-before是用来描述两个操作的内存可见性，X happens-before Y 那么X对Y可见。

所以java内存模型是通过内存屏障来禁止指令重排的，对于读读，读写，写写都是插入空指令操作，对于写读用的实际指令，强制写缓存。

写缓存是一项优化，从主存中获取值进行计算出结果并不立即同步至主存，可能会放到寄存器里面，等完成其他指令操作后才写入主存，而处理器刷新写缓存就是立即同步到主存，由于内存写操作时会无效化其他处理器所持有的、指向同一区域的内存缓存行，所以可以说是立即可见最新的值

### synchronized

#### 重量级锁

是jvm最基础的实现，java虚拟机会阻塞这些加锁失败的线程，并且在目标锁被释放的时候唤醒这些线程。

java线程的阻塞和唤醒是通过操作系统来实现的，对于posix接口的操作系统， 是通过 pthread 的互斥锁来实现的，这些操作设计系统调用，需要操作系统从用户态切换到内核态。

由于挂起唤醒操作非常耗费性能，所以在线程竞争不到锁的时候陷入自旋轮训状态，如果在期间锁释放就可以去获取。当然自旋也是耗费资源的，这个等待时间太长还不如挂起，所以需要预测需要自旋多久，就是根据以往自旋等待时间能否获得锁，来调整自旋的时间，还有个不公平机制，就是处于挂起的线程被唤醒的时候无法**立即争抢锁**

，而自旋状态的线程马上就能抢到

#### 轻量级锁