## java虚拟机概述

定义：java首先会将class文件加载到java虚拟机，加载后的java类放在方法去，需要用到的时候再去执行这些方法区里的代码。

### java内存结构

线程共享：

1.堆：存放对象的区域

2.方法区：存放字节码的地方，执行代码时会调用

线程私有：

1.栈：线程私有，分为java方法栈和本地方法栈

2.PC寄存器：存放各个线程执行位置的

### java执行效率

首先，在jvm中java代码有两种执行方式。

解释执行：取出方法区带代码一句一句的翻译成机器码并执行。优点是无需等待。

编译执行：把方法中包含的字节码全部翻译后在执行，优点的是实际执行时间较快

虚拟机HotSpot就采用了多种技术来提升启动性能和峰值性能，其中即时编译便是其中最重要的技术。

不管在现实世界中还是jvm中都符合一个二八定律，就是百分之二十的代码占据了百分之八十的计算机资源。

那么，就可以对这百分之二十的代码进行编译成机器码提高峰值性能，而剩下百分之八十不是那么太常用的代码就无需话费时间编译成机器码，而采用解释执行的方式

HotSpot虚拟机就有多种即时编译器C1、C2、Graal，其中C1是针对启动性能有要求的所以优化方式比较简单，速度也比较快。C2也称为Server即时编译器，优化方式比较复杂适用于对峰值性能有要求的。Graal是java10新加入的一种实验型的即时编译器。

因为有了即时编译器的存在所以说在某种情况下java的执行效率是高于C++的，因为C++采用的是静态编译的方式，相对于java灵活的优化编译手段在某些时候是比不上java的。

比如，面向对象最重要的特征是多态，只有调用的时候才能确定调用者的具体类型，而一般情况下是需要去方法表里面去寻找这个调用者，这个调用者的信息及时编译器就可以进行一个保存优化。

HotSpot采用的是多种编译方式相结合的，取多种编译器的优点，来进行优化，热点方法就会进行一个分层编译，首先经过C1，然后经过C2编译，为了不干扰程序的正常运行，HotSpot是将及时编译放在额外的线程中执行的，C1:C2的比例为1：2线程数根据cpu核数分配。

正常执行程序和即时编译可以同时运行，等到热点方法达到阈值进行一个替换就可以了。

## java类的加载

### 加载

类的加载是查找字节流，根据字节流创建类的过程，然而类既然要被加载肯定需要一个东西加载它，类加载器就是做这件事的，启动类加载器（bootstrap class loader）,这个类是用C++写的因此没有可映射的对象。

除了启动类加载器其他类加载器都是java.class.ClassLoader的子类，类是由java写的因此有具体的类对象。

因为确定类的唯一性是由加载器+类名确定的，所以不同的加载器加载同一个字节流也会得到两个不同的类，所以虚拟机采用了一种双亲委派模型，指的就是加载器加载一个类的时候会让父类去加载，层层往上，让同一个字节流能够表示同一个类，当然也可以利用这一个特性，自己编写加载器得到一个类不同的两个版本。

### 链接

链接指的是将一个类合并至java虚拟机的过程，转化为可以执行的程序的一个过程，其中又分为验证、准备、解析三个部分

#### 验证

此阶段主要验证java代码符不符合规范，一般通过javac的都没问题

#### 准备

此阶段会为静态属性分配内存初值，并且构建与类层次相关的数据结构，例如方法虚表。因为加载到虚拟机之前是不知道调用方法具体地址，对象的引用地址，虚拟机就会生成一个符号引用，此引用会无歧义的定位到目标位置上。

#### 解析

此阶段就是把符号引用替换成实际引用，如果指向的类未被加载，则会触发该类的加载，静态方法直接指向方法地址，实例方法或者虚方法就只会得到一个方法表的索引值等到实际调用的时候再去方法表寻找具体是谁。

### 初始化

最后一步就是对静态字段进行一个赋值，会把所有静态代码块和常量赋值操作放到<init>方法中进行初始化，此方法会通过加锁的方式来保证只会初始化一次，所以单例模式中也可以利用类加载这个初始化阶段来做。比如建立一个静态内部类，里面 final 静态字段修饰需要调用的单例

```java
public class Singleton {
    private Singleton() {
    }
    
    private static class LazyHolder {
        static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return LazyHolder.INSTANCE;
    }
}
```

