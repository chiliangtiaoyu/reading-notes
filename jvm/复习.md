# 1

### 线程私有

PC计数器

本地方法栈

java方法栈

### 线程共享

方法区

堆

解释执行 :逐行翻译执行

编译执行jit：先把字节码编译成机器码在执行

hotspot混合模式，热点代码以方法为单位

C1：Client编译器 优化启动时间对启动有要求的GUI 优化简单启动时间短

C2：Server编译器 优化执行时间 WEB项目适用 优化复杂编译时间长

1：2比例分配

分层编译：热点方法被C1，热点方法中的热点在被C2编译

# 3

加载

链接

1.验证

2.准备 为静态变量分配内存 生成符号引用

3.解析 符合引用的替换成实际引用 非必须

初始化  赋值 静态代码执行 < clinit > 

# 4

方法描述符 虚拟机确定方法 类名+方法名字+参数类型+返回类型，虚拟机和java语言不一样 

符号引用 ->实际引用

不需要动态绑定的 就是指向方法的指针

动态绑定，就是方法表的索引

# 5

动态绑定->找到栈上调用者->获取调用者类型->获取实际引用的索引值->获取方法表->找到方法表中对应的索引位

内联缓存

直接根据调用者类型，获取对应方法

# 7

动态实现 本地实现

委派为本地实现的invoke方法是一个native方法，需要从java到C到java的转换，动态实现是java版本的 

# 10

内存布局

标记字段 类型指针 64 + 64

指针压缩 64->32 由存地址变为存对象号数 所以**对象必须是8N对齐**

解引用 左移三位，加上一个固定偏移量 得到64位伪指针地址

**字段内存对齐**

防止在不同缓存行 执行效率低 因为读两次

**字段重排列**

字段占C字节 那么NC对齐

逻辑共享 实际共享

 @Contended 独立缓存行

# 11

可达性分析 引用计数法

stop the world安全点检测

安全点：JNI执行本地代码 阻塞

解释执行字节码 执行即时编译器生成的机器码

字节码与字节码之间 机器码插入安全点检测，

机器码方法出口和非计数循环回边处插入安全点，因为打乱了栈帧对象分布情况，所以需要提供额外的信息

安全点检测怎么实现：

把一块内存设置为不可读，谁访问谁就挂起

# 12

eden survivor 根据对象生成速度动态分配比例

TLAB

老年代 15 survivor 50%

卡表的作用 怎么标记为脏卡

卡表也有虚共享 

G1 人如其名

# 13

volatile 内存屏障 我之前的不能在我之后

**写缓存技术**

**强制刷新缓存**

内存写操作 会无效化其他写操作 

# 14

 synchronized 实现原理

重入锁怎么实现

重量级锁 自选

轻量级

偏向 epoch

# 20

简述C1 C2

方法内联触发条件 方法内联节省了什么

机器码放到CodeCache 大小可调

# 21

条件去虚化 证明这个是最常用且没有其他类型 收集类型profile

完全去虚化 证明是唯一方法。类层次分析

都是为了直接内联调用