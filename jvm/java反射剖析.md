# java反射剖析

既然要说反射，那么就必须要先搞懂java的方法是怎样的一个调用过程。

## java方法调用

### 方法绑定

分为静态绑定和动态绑定，首先方法调用编译成汇编指令的时候，对应五种方法调用类型分别是：

**invokestatic** ：静态方法调用指令

**invokespecial** ：特殊方法调用指令例如构造方法super方法

**invokevirtual**  ：实例化对象的非私有方法

**invokeinterface** ：接口方法

**invokedynamic**：方法句柄指令

前两者属于静态绑定，因为在调用的时候不需要进行判断直接可以确定方法本身

后面三个属于动态绑定需要根据调用者类型进行确定方法地址，所以实际上动态绑定实际上绑定的不是方法本身而是一个方法表的索引值，每次就需要拿着调用者的类型去方法表里去找。

什么是方法表的索引值呢？

先说下索引值是什么，方法表其实就是一个数组，数组的索引位就是指令所绑定的值。

子类重写父类的方法索引位与父类相同，给一个例子：

```java
class Person {

    public void getName() {
        System.out.println("我是一个人");
    }

    @Override
    public String toString() {
        return super.toString();
    }
}
class SuperPerson extends Person{

    @Override
    public void getName() {
        System.out.println("我是一个超人");
    }

    @Override
    public String toString() {
        return super.toString();
    }

    public void feature(){
        System.out.println("我会飞");
    }
}
```

​									Object的方法表

| 索引位 | 方法名     |
| :----- | ---------- |
| 0      | toString() |

​									Person的方法表

| 索引位 | 方法名     |
| :----- | ---------- |
| 0      | toString() |
| 1      | getName()  |

​								SuperPerson的方法表

| 索引位 | 方法名     |
| :----- | ---------- |
| 0      | toString() |
| 1      | getName()  |
| 2      | feature()  |

现在可以看到索引值相同方法名字也相同，所以当做虚方法调用的时候只需要拿到索引值进行类型匹配就行了，这样看来好像虚调用和静态绑定比起来只多了几个引用操作，这点消耗忽略不计，但其实不是这样的。

因为这种情况只有解释执行和即时编译器中情况最差的情况效率差不多，在即时编译器中，存在内联缓存和方法内联两种情况，由于方法内联比较复杂涉及的东西比较多，所以现在只介绍一下内联缓存，方法内联在后面在介绍

内联缓存的实现比较简单，就是判断调用者类型是否被缓存起来，如果命中缓存直接调用缓存目标方法

内联缓存又分为

**单态内联**：缓存一个调用者类型

**多态内联**：缓存多个，按照热点方法排序

**超态内联**：不缓存

也不是说缓存一定就好，比如单态缓存调用者类型不断变更，那还不如不缓存直接查表，还增加了刷新缓存的消耗。这章主要讨论反射，这里不做过多的解释